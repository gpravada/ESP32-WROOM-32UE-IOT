// #include "driver/gpio.h"
// #include "driver/i2c.h"
// #include "esp_err.h"
// #include "esp_log.h"
// #include "freertos/task.h"

// #include "sdkconfig.h" // generated by "make menuconfig"

// #include "bme280.h"

// #define LED_GPIO_PIN 5

// #define SCL_PIN GPIO_NUM_19
// #define SDA_PIN GPIO_NUM_18

// #define TAG_BME280 "BME280"

// #define I2C_MASTER_ACK 0
// #define I2C_MASTER_NACK 1

// static int led_state = 1u;

// void i2c_master_init()
// {
// 	i2c_config_t i2c_config = {
// 		.mode = I2C_MODE_MASTER,
// 		.sda_io_num = SDA_PIN,
// 		.scl_io_num = SCL_PIN,
// 		.sda_pullup_en = GPIO_PULLUP_ENABLE,
// 		.scl_pullup_en = GPIO_PULLUP_ENABLE,
// 		.master.clk_speed = 1000000
// 	};
// 	ESP_LOGI(TAG_BME280, "i2c_master_init: %d", 0);

// 	i2c_param_config(I2C_NUM_0, &i2c_config);
// 	ESP_LOGI(TAG_BME280, "i2c_master_init: %d", 1);

// 	i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, 0, 0, 0);
// 	ESP_LOGI(TAG_BME280, "i2c_master_init: %d", I2C_MODE_MASTER);
// }

// s8 BME280_I2C_bus_write(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)
// {
// 	s32 iError = BME280_INIT_VALUE;

// 	esp_err_t espRc;
// 	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

// 	i2c_master_start(cmd);
// 	i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_WRITE, true);

// 	i2c_master_write_byte(cmd, reg_addr, true);
// 	i2c_master_write(cmd, reg_data, cnt, true);
// 	i2c_master_stop(cmd);

// 	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
// 	if (espRc == ESP_OK) {
// 		iError = SUCCESS;
// 	} else {
// 		iError = ESP_FAIL;
// 	}
// 	i2c_cmd_link_delete(cmd);

// 	return (s8)iError;
// }

// s8 BME280_I2C_bus_read(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)
// {
// 	s32 iError = BME280_INIT_VALUE;
// 	esp_err_t espRc;

// 	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

// 	i2c_master_start(cmd);
// 	i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_WRITE, true);
// 	i2c_master_write_byte(cmd, reg_addr, true);

// 	i2c_master_start(cmd);
// 	i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_READ, true);

// 	if (cnt > 1) {
// 		i2c_master_read(cmd, reg_data, cnt-1, I2C_MASTER_ACK);
// 	}
// 	i2c_master_read_byte(cmd, reg_data+cnt-1, I2C_MASTER_NACK);
// 	i2c_master_stop(cmd);

// 	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
// 	if (espRc == ESP_OK) {
// 		iError = SUCCESS;
// 	} else {
// 		iError = ESP_FAIL;
// 	}

// 	i2c_cmd_link_delete(cmd);

// 	return (s8)iError;
// }

// void BME280_delay_msek(u32 msek)
// {
// 	vTaskDelay(msek/portTICK_PERIOD_MS);
// }

// void bme280_reader_task(void *ignore)
// {
// 	struct bme280_t bme280 = {
// 		.bus_write = BME280_I2C_bus_write,
// 		.bus_read = BME280_I2C_bus_read,
// 		.dev_addr = BME280_I2C_ADDRESS1,
// 		.delay_msec = BME280_delay_msek
// 	};

// 	s32 com_rslt;
// 	s32 v_uncomp_pressure_s32;
// 	s32 v_uncomp_temperature_s32;
// 	s32 v_uncomp_humidity_s32;

// 	com_rslt = bme280_init(&bme280);

// 	com_rslt += bme280_set_oversamp_pressure(BME280_OVERSAMP_16X);
// 	com_rslt += bme280_set_oversamp_temperature(BME280_OVERSAMP_2X);
// 	com_rslt += bme280_set_oversamp_humidity(BME280_OVERSAMP_1X);

// 	com_rslt += bme280_set_standby_durn(BME280_STANDBY_TIME_1_MS);
// 	com_rslt += bme280_set_filter(BME280_FILTER_COEFF_16);

// 	com_rslt += bme280_set_power_mode(BME280_NORMAL_MODE);
// 	if (com_rslt == SUCCESS) {
// 		ESP_LOGI(TAG_BME280, "com_rslt success: %d", com_rslt);

// 		while(true) {
//             led_state = !led_state;
//             gpio_set_level(LED_GPIO_PIN, led_state);

// 			vTaskDelay(1000/portTICK_PERIOD_MS);

// 			ESP_LOGI(TAG_BME280, "read sensor data: %d", led_state);

// 			com_rslt = bme280_read_uncomp_pressure_temperature_humidity(
// 				&v_uncomp_pressure_s32, &v_uncomp_temperature_s32, &v_uncomp_humidity_s32);

// 			if (com_rslt == SUCCESS) {
// 				ESP_LOGI(TAG_BME280, "Temperature: %.2f degC / Pressure: %.3f hPa / Humidity: %.3f %%",
// 					bme280_compensate_temperature_double(v_uncomp_temperature_s32),
// 					bme280_compensate_pressure_double(v_uncomp_pressure_s32)/100, // Pa -> hPa
// 					bme280_compensate_humidity_double(v_uncomp_humidity_s32));
// 			} else {
// 				ESP_LOGE(TAG_BME280, "measure error. code: %d", com_rslt);
// 			}
// 		}
// 	} else {
// 		ESP_LOGE(TAG_BME280, "init or setting error. code: %d", com_rslt);
// 	}

// 	vTaskDelete(NULL);
// }

// void app_main(void)
// {
//     // LED init.
//     esp_rom_gpio_pad_select_gpio(LED_GPIO_PIN);
//     gpio_set_direction(LED_GPIO_PIN, GPIO_MODE_OUTPUT);

// 	ESP_LOGI(TAG_BME280, "Led init Done: %d", LED_GPIO_PIN);

// 	i2c_master_init();
// 	xTaskCreate(&bme280_reader_task, "bme280_reader_task",  2048, NULL, 6, NULL);
// }

#include <stdio.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <esp_system.h>

#include "bmp280.h"
#include "led_app.h"

#include <string.h>

#ifndef APP_CPU_NUM
#define APP_CPU_NUM PRO_CPU_NUM
#endif

void bmp280_test(void *pvParameters)
{
    bmp280_params_t params;
    bmp280_init_default_params(&params);
    bmp280_t dev;
    memset(&dev, 0, sizeof(bmp280_t));

    ESP_ERROR_CHECK(bmp280_init_desc(&dev, BMP280_I2C_ADDRESS_0, 0, GPIO_NUM_22, GPIO_NUM_21));
    ESP_ERROR_CHECK(bmp280_init(&dev, &params));

    bool bme280p = dev.id == BME280_CHIP_ID;
    printf("BMP280: found %s\n", bme280p ? "BME280" : "BMP280");

    float pressure, temperature, humidity;

    while (1)
    {
        vTaskDelay(pdMS_TO_TICKS(5000));
        if (bmp280_read_float(&dev, &temperature, &pressure, &humidity) != ESP_OK)
        {
            printf("Temperature/pressure reading failed\n");
            continue;
        }

        /* float is used in printf(). you need non-default configuration in
         * sdkconfig for ESP8266, which is enabled by default for this
         * example. see sdkconfig.defaults.esp8266
         */
        printf("Pressure: %.2f hPa, Temperature: %.2f degC", pressure/100, temperature);
        if (bme280p)
            printf(", Humidity: %.2f\n", humidity);
        else
            printf("\n");
    }
}

void app_main()
{
    // LED init.
    led_init();
    xTaskCreatePinnedToCore(&led_blink_task, "led_blink_task",  1024, NULL, 6, NULL, PRO_CPU_NUM);

    ESP_ERROR_CHECK(i2cdev_init());
    xTaskCreatePinnedToCore(bmp280_test, "bmp280_test", configMINIMAL_STACK_SIZE * 8, NULL, 5, NULL, APP_CPU_NUM);
}